import torch
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from sklearn.metrics import roc_auc_score, precision_recall_curve, auc
import matplotlib.pyplot as plt

# --- 1. Baseline Autoencoder (Non-probabilistic) ---
class Autoencoder(nn.Module):
    def __init__(self, input_dim, latent_dim):
        super(Autoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 16), nn.ReLU(),
            nn.Linear(16, latent_dim)
        )
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 16), nn.ReLU(),
            nn.Linear(16, input_dim)
        )
    def forward(self, x):
        return self.decoder(self.encoder(x))

# --- 2. Training Loop Utility ---
def train_model(model, train_loader, epochs=50, is_vae=True, beta=1.0):
    optimizer = optim.Adam(model.parameters(), lr=1e-3)
    model.train()
    
    for epoch in range(epochs):
        for batch_x, in train_loader:
            optimizer.zero_grad()
            if is_vae:
                recon, mu, logvar = model(batch_x)
                loss = loss_function(recon, batch_x, mu, logvar, beta)
            else:
                recon = model(batch_x)
                loss = F.mse_loss(recon, batch_x)
            loss.backward()
            optimizer.step()

# --- 3. Execution & Evaluation ---
X, y = generate_data(n_samples=5000)
X_tensor = torch.tensor(X)
train_loader = DataLoader(TensorDataset(X_tensor), batch_size=64, shuffle=True)

# Initialize Models
input_dim = X.shape[1]
latent_dim = 2
vae = VAE(input_dim, latent_dim)
ae = Autoencoder(input_dim, latent_dim)

# Train
train_model(vae, train_loader, is_vae=True, beta=0.5)
train_model(ae, train_loader, is_vae=False)

# Get Reconstruction Errors for Anomaly Detection
vae.eval()
ae.eval()
with torch.no_grad():
    # VAE Error
    recon_vae, _, _ = vae(X_tensor)
    vae_errors = torch.mean((recon_vae - X_tensor)**2, dim=1).numpy()
    
    # AE Error
    recon_ae = ae(X_tensor)
    ae_errors = torch.mean((recon_ae - X_tensor)**2, dim=1).numpy()

# Calculate Metrics
vae_auc = roc_auc_score(y, vae_errors)
ae_auc = roc_auc_score(y, ae_errors)

print(f"VAE AUC-ROC: {vae_auc:.4f}")
print(f"AE AUC-ROC: {ae_auc:.4f}")

